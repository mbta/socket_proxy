# SocketProxy

A simple app that listens on a port and proxies (and possibly fans out) data to multiple given destinations. Each incoming connection is fanned out independently to all the destinations. For example, 2 sources and 2 destinations results in 6 sockets: 2 incoming, and 4 outgoing (2 to each).

## Usage

```
$ mix socket_proxy --listen-port 8001 12.12.12.12:8002 13.13.13.13:8003
```

## Testing

This app comes with a fake sources which generate random strings and fake servers which can serve as the destinations. Here's how to set them up.

Open several terminal windows, all in the socket_proxy directory.

Start up a couple servers on different ports:
https://assets.head-hunters.org/puzzles/what_the/03-fe4a6b245f.png
```
$ mix fake_destination --port 8080  # in one window
$ mix fake_destination --port 8081  # in another window
```

In more terminal windows, start up the sources which will attempt to connect to a port and then start sending random bytes once the connection is made.

```
$ mix fake_source --port 8000
$ mix fake_source --port 8000
```

You can then run socket proxy to connect them all:

```
$ mix socket_proxy --listen-port 8000 127.0.0.1:8080 127.0.0.1:8081
```

Observe that data being generated by the two fake sources appear in both the fake servers. Try killing and restarting any combination of the windows and see that the data continues to flow.

## Architecture

The entry point is the `SocketProxy` GenServer, which should be started by a supervisor (this is what the `mix socket_proxy` task does). It is a single process that listens on a port and then operates a `gen_tcp` accept loop, accepting all incoming connections.

Each accepted connection spawns a new process where it is handled by a `SocketProxy.Receiver`. This process in turn spawns *and links* a `SocketProxy.Forwarder` GenServer for each of its destinations. Incoming data is handled by the `Receiver` process, and fanned out to each destination by sending a `{:data, data}` message.

Because the `Receiver` is linked to the `Forwarder`s, if any of them crash or exit, *all* of them do. This is to help manage cleanup should the Receiver fail (incoming data socket is broken). If that happens, it and all the Forwarder processes exit, and hopefully the source will re-connect to socket_proxy, which will accept it from its running accept loop, and spawn a new Receiver, which spawns new linked Forwarders, and the process continues.
