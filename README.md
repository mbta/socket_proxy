# SocketProxy

A simple app that listens on a port and proxies (and possibly fans out) data to multiple given destinations. Each incoming connection is fanned out independently to all the destinations. For example, 2 sources and 2 destinations results in 6 sockets: 2 incoming, and 4 outgoing (2 to each).

## Usage

```
$ env SOCKET_PROXY_LISTEN_PORT=8001 SOCKET_PROXY_DESTINATIONS="12.12.12.12:8002, 13.13.13.13:8003" mix run --no-halt
```

## Testing

This app comes with a fake sources which generate random strings and fake servers which can serve as the destinations. Here's how to set them up.

Open several terminal windows, all in the socket_proxy directory.

Start up a couple servers on different ports:

```
$ mix fake_destination --port 8080  # in one window
$ mix fake_destination --port 8081  # in another window
```

In more terminal windows, start up the sources which will attempt to connect to a port and then start sending random bytes once the connection is made.

```
$ mix fake_source --port 8000
$ mix fake_source --port 8000
```

You can then run socket proxy to connect them all:

```
$ env SOCKET_PROXY_LISTEN_PORT=8000 SOCKET_PROXY_DESTINATIONS="127.0.0.1:8080, localhost:8081" mix run --no-halt
```

Observe that data being generated by the two fake sources appear in both the fake servers. Try killing and restarting any combination of the windows and see that the data continues to flow.

## Architecture

This is an OTP application that starts two children: the main `SocketProxy` GenServer and a `SocketProxy.ReceiverSupervisor` `:simple_one_for_one` Dynamic Supervisor.

The `SocketProxy` GenServer listens on a port and operates a `gen_tcp` accept loop. In order to be a good OTP citizen, it manages the accept loop by calling `:gen.tcp.accept/2` with a timeout, and then casting itself a message to try again. That way, other messages (e.g. from its Supervisor) have a chance to be processed.

When `SocketProxy` does accept a connection, it starts a `SocketProxy.Receiver` child under the `SocketProxy.ReceiverSupervisor`. This process in turn spawns *and links* a `SocketProxy.Forwarder` GenServer for each of its destinations. Incoming data is handled by the `Receiver` process, and fanned out to each destination by sending a `{:data, data}` message.

Because the `Receiver` is linked to the `Forwarder`s, if any of them crash or exit, *all* of them do. This is to help manage cleanup should the Receiver fail (incoming data socket is broken). If that happens, it and all the Forwarder processes exit, and the source should re-connect to socket_proxy, which will accept it from its running accept loop, and spawn a new Receiver, which spawns new linked Forwarders, and so on.

## Deploys

Socket proxy runs as a Windows services on Opstech3.

On Opstech3 there is a user, RTRUser where the code and compiled artifacts live. In order to access /c/Users/RTRUser/ in Git Bash, you will have to navigate to the directory in the Windows GUI Explorer. The first time you open it, it will prompt you for permissions, and then after that you'll have access via Git Bash.

The version of Erlang we use is precompiled Erlang/OTP, installed via [this Windows installer](https://www.erlang-solutions.com/resources/download.html) to /c/Users/RTRUser/bin/.

The version of Elixir we use is precompiled Elixir, downloaded [here](https://github.com/elixir-lang/elixir/releases) and unzipped to /c/Users/RTRUser/bin.

The `socket_proxy` code is git cloned to /c/Users/RTRUser/GitHub/socket_proxy_release_prod/.

We build the application via Elixir-native `mix release`, setting the `PATH` to include the aforementioned versions of Elixir and Erlang. The release gets built into `_build\prod\rel\`.

To manage the Windows service we use [`nssm`](https://nssm.cc/). The service is configured via `nssm edit socket-proxy-prod`. In particular, environment variables are added there, and the app launch is configured there. The app is configured to launch as follows:

* Path: `C:\Users\RTRUser\GitHub\socket_proxy_release_prod\_build\prod\rel\socket_proxy\bin\socket_proxy.bat`
* Startup directory: `C:\Users\RTRUser\GitHub\socket_proxy_release_prod`
* Arguments: `start`

To deploy a new version of the code:

1. In Git Bash, navigate to `/c/Users/RTRUser/GitHub/socket_proxy_release_prod`
1. `git pull` the latest version
1. Run `./build_release.sh socket_proxy_prod` to compile a new release. The second argument gives the name of the Erlang node to run the release under and isn't terribly important.
1. Open the Windows Services application and restart `socket-proxy-prod`
1. Tag the release in git: `git tag -a yyyy-mm-dd -m "Deployed on [date] at [time]"`
1. Push the tag to GitHub: `git push origin yyyy-mm-dd`

## Rolling back
To quickly roll back to a previous version:

1. Move the broken release: `mv _build _build-broken`
1. Restore the previous release: `mv _build-prev _build`
1. Restart the service
